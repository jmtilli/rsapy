import Crypto
from Crypto.PublicKey import RSA
from Crypto.Signature import PKCS1_v1_5
from Crypto.Hash import SHA256
from Crypto import Random

from Crypto.Util.asn1 import DerSequence
import binascii
import time
from binascii import a2b_base64

def importCert(pem):
  lines = pem.replace(" ",'').split()
  der = a2b_base64(''.join(lines[1:-1]))
  cert = DerSequence()
  cert.decode(der)
  tbscert = DerSequence()
  tbscert.decode(cert[0])
  return RSA.importKey(tbscert[6])

def myImportCert(pem):
  pub = importCert(pem)
  return MyRsaPubKey(n=pub.n, e=pub.e)

def myImportKey(pem):
  key = RSA.importKey(pem, passphrase=None)
  dp = key.d % (key.p-1)
  dq = key.d % (key.q-1)
  return MyRsaPrivKey(dp=dp, dq=dq, qinv=key.u, p=key.p, q=key.q,
                      e=key.e, d=key.d, n=key.n)
  
with open("../http2/key.pem") as f:
  priv = RSA.importKey(f.read(), passphrase=None)
with open("../http2/cert.pem") as f:
  pub = importCert(f.read())

message = 'hi'
#signature = priv.sign('hi', 32)
signer = PKCS1_v1_5.new(priv)
digest = SHA256.new()
digest.update(message)
signature = signer.sign(digest)

print repr(signature)
print len(signature)

#def modexp(m,e,n):
#  b = 1
#  # invariant: b * m**e stays the same
#  assert e >= 0
#  while e > 0:
#    if e % 2 == 0:
#      m *= m
#      m %= n
#      e /= 2
#    else:
#      b *= m
#      b %= n
#      e -= 1
#  return b
def modexp(m,e,n):
  return pow(m,e,n)

class MyRsaPubKey(object):
  def __init__(this, e, n):
    this.e = e
    this.n = n
  def verifyEncrypt(this, m):
    return modexp(m, this.e, this.n)

class MyRsaPrivKey(object):
  def __init__(this, dp, dq, qinv, p, q, e, d, n):
    #this.dp = dp
    this.dp = dq
    #this.dq = dq
    this.dq = dp
    this.qinv = qinv
    #this.p = p
    this.p = q
    #this.q = q
    this.q = p
    this.e = e
    this.d = d
    this.n = n
    assert this.dp == this.d % (this.p - 1)
    assert this.dq == this.d % (this.q - 1)
    assert (this.qinv * this.q) % this.p == 1
  def signDecrypt(this, c):
    m1 = modexp(c, this.dp, this.p)
    m2 = modexp(c, this.dq, this.q)
    if m1 < m2:
      print "Alternative path"
      toadd = ((this.q+this.p-1)/this.p)*this.p
      assert m1 + toadd >= m2
      h = (this.qinv*((m1 + toadd) - m2)) % this.p
      #h = (this.qinv * (m1-m2)) % this.p
    else:
      h = (this.qinv * (m1-m2)) % this.p
    m = m2 + h * this.q
    #assert m%this.n == modexp(c, this.d, this.n)
    #assert m == modexp(c, this.d, this.n)
    return m
    return (this.n*100 + m) % this.n
    return modexp(c, this.d, this.n)

def longToBytes(val):
  w = long(val).bit_length()
  w = (w+7)//8 * 8
  formatString = '%%0%dx' % (w//4)
  return binascii.unhexlify(formatString % val)
def bytesToLong(val):
  return long(binascii.hexlify(val), 16)
  

class DiffieHellmanParameters(object):
  def __init__(this, p, g, expmin = None):
    this.p = p
    this.g = g
    this.expmin = expmin
  def send(this, secret):
    return IntermediateDiffieHellman(this, modexp(this.g, secret, this.p))
    #return IntermediateDiffieHellman(this, (this.g**secret) % this.p)
  def sendPad(this, secret):
    return longToBytes(modexp(this.g, secret, this.p))

class IntermediateDiffieHellman(object):
  def __init__(this, params, intermediate):
    this.params = params
    if type(intermediate) == bytes or type(intermediate) == str:
      this.intermediate = bytesToLong(intermediate)
    else:
      this.intermediate = intermediate
  def recv(this, secret):
    return modexp(this.intermediate, secret, this.params.p)
    #return (this.intermediate ** secret) % this.params.p

params = DiffieHellmanParameters(23, 5)
a = 4
b = 3
A = params.send(a)
B = params.send(b)
shared1 = B.recv(a)
shared2 = A.recv(b)
assert shared1 == 18
assert shared2 == 18

groups = {}

# ffdhe3072
p = 0xFFFFFFFFFFFFFFFFADF85458A2BB4A9AAFDC5620273D3CF1D8B9C583CE2D3695A9E13641146433FBCC939DCE249B3EF97D2FE363630C75D8F681B202AEC4617AD3DF1ED5D5FD65612433F51F5F066ED0856365553DED1AF3B557135E7F57C935984F0C70E0E68B77E2A689DAF3EFE8721DF158A136ADE73530ACCA4F483A797ABC0AB182B324FB61D108A94BB2C8E3FBB96ADAB760D7F4681D4F42A3DE394DF4AE56EDE76372BB190B07A7C8EE0A6D709E02FCE1CDF7E2ECC03404CD28342F619172FE9CE98583FF8E4F1232EEF28183C3FE3B1B4C6FAD733BB5FCBC2EC22005C58EF1837D1683B2C6F34A26C1B2EFFA886B4238611FCFDCDE355B3B6519035BBC34F4DEF99C023861B46FC9D6E6C9077AD91D2691F7F7EE598CB0FAC186D91CAEFE130985139270B4130C93BC437944F4FD4452E2D74DD364F2E21E71F54BFF5CAE82AB9C9DF69EE86D2BC522363A0DABC521979B0DEADA1DBF9A42D5C4484E0ABCD06BFA53DDEF3C1B20EE3FD59D7C25E41D2B66C62E37FFFFFFFFFFFFFFFF
g = 2
expmin = 275
groups[0x0101] = DiffieHellmanParameters(p, g, expmin)

# ffdhe2048
p = 0xFFFFFFFFFFFFFFFFADF85458A2BB4A9AAFDC5620273D3CF1D8B9C583CE2D3695A9E13641146433FBCC939DCE249B3EF97D2FE363630C75D8F681B202AEC4617AD3DF1ED5D5FD65612433F51F5F066ED0856365553DED1AF3B557135E7F57C935984F0C70E0E68B77E2A689DAF3EFE8721DF158A136ADE73530ACCA4F483A797ABC0AB182B324FB61D108A94BB2C8E3FBB96ADAB760D7F4681D4F42A3DE394DF4AE56EDE76372BB190B07A7C8EE0A6D709E02FCE1CDF7E2ECC03404CD28342F619172FE9CE98583FF8E4F1232EEF28183C3FE3B1B4C6FAD733BB5FCBC2EC22005C58EF1837D1683B2C6F34A26C1B2EFFA886B423861285C97FFFFFFFFFFFFFFFF
g = 2
expmin = 225
groups[0x0100] = DiffieHellmanParameters(p, g, expmin)

# ffdhe4096
p = 0xFFFFFFFFFFFFFFFFADF85458A2BB4A9AAFDC5620273D3CF1D8B9C583CE2D3695A9E13641146433FBCC939DCE249B3EF97D2FE363630C75D8F681B202AEC4617AD3DF1ED5D5FD65612433F51F5F066ED0856365553DED1AF3B557135E7F57C935984F0C70E0E68B77E2A689DAF3EFE8721DF158A136ADE73530ACCA4F483A797ABC0AB182B324FB61D108A94BB2C8E3FBB96ADAB760D7F4681D4F42A3DE394DF4AE56EDE76372BB190B07A7C8EE0A6D709E02FCE1CDF7E2ECC03404CD28342F619172FE9CE98583FF8E4F1232EEF28183C3FE3B1B4C6FAD733BB5FCBC2EC22005C58EF1837D1683B2C6F34A26C1B2EFFA886B4238611FCFDCDE355B3B6519035BBC34F4DEF99C023861B46FC9D6E6C9077AD91D2691F7F7EE598CB0FAC186D91CAEFE130985139270B4130C93BC437944F4FD4452E2D74DD364F2E21E71F54BFF5CAE82AB9C9DF69EE86D2BC522363A0DABC521979B0DEADA1DBF9A42D5C4484E0ABCD06BFA53DDEF3C1B20EE3FD59D7C25E41D2B669E1EF16E6F52C3164DF4FB7930E9E4E58857B6AC7D5F42D69F6D187763CF1D5503400487F55BA57E31CC7A7135C886EFB4318AED6A1E012D9E6832A907600A918130C46DC778F971AD0038092999A333CB8B7A1A1DB93D7140003C2A4ECEA9F98D0ACC0A8291CDCEC97DCF8EC9B55A7F88A46B4DB5A851F44182E1C68A007E5E655F6AFFFFFFFFFFFFFFFF
g = 2
expmin = 325
groups[0x0102] = DiffieHellmanParameters(p, g, expmin)

# ffdhe6144
p = 0xFFFFFFFFFFFFFFFFADF85458A2BB4A9AAFDC5620273D3CF1D8B9C583CE2D3695A9E13641146433FBCC939DCE249B3EF97D2FE363630C75D8F681B202AEC4617AD3DF1ED5D5FD65612433F51F5F066ED0856365553DED1AF3B557135E7F57C935984F0C70E0E68B77E2A689DAF3EFE8721DF158A136ADE73530ACCA4F483A797ABC0AB182B324FB61D108A94BB2C8E3FBB96ADAB760D7F4681D4F42A3DE394DF4AE56EDE76372BB190B07A7C8EE0A6D709E02FCE1CDF7E2ECC03404CD28342F619172FE9CE98583FF8E4F1232EEF28183C3FE3B1B4C6FAD733BB5FCBC2EC22005C58EF1837D1683B2C6F34A26C1B2EFFA886B4238611FCFDCDE355B3B6519035BBC34F4DEF99C023861B46FC9D6E6C9077AD91D2691F7F7EE598CB0FAC186D91CAEFE130985139270B4130C93BC437944F4FD4452E2D74DD364F2E21E71F54BFF5CAE82AB9C9DF69EE86D2BC522363A0DABC521979B0DEADA1DBF9A42D5C4484E0ABCD06BFA53DDEF3C1B20EE3FD59D7C25E41D2B669E1EF16E6F52C3164DF4FB7930E9E4E58857B6AC7D5F42D69F6D187763CF1D5503400487F55BA57E31CC7A7135C886EFB4318AED6A1E012D9E6832A907600A918130C46DC778F971AD0038092999A333CB8B7A1A1DB93D7140003C2A4ECEA9F98D0ACC0A8291CDCEC97DCF8EC9B55A7F88A46B4DB5A851F44182E1C68A007E5E0DD9020BFD64B645036C7A4E677D2C38532A3A23BA4442CAF53EA63BB454329B7624C8917BDD64B1C0FD4CB38E8C334C701C3ACDAD0657FCCFEC719B1F5C3E4E46041F388147FB4CFDB477A52471F7A9A96910B855322EDB6340D8A00EF092350511E30ABEC1FFF9E3A26E7FB29F8C183023C3587E38DA0077D9B4763E4E4B94B2BBC194C6651E77CAF992EEAAC0232A281BF6B3A739C1226116820AE8DB5847A67CBEF9C9091B462D538CD72B03746AE77F5E62292C311562A846505DC82DB854338AE49F5235C95B91178CCF2DD5CACEF403EC9D1810C6272B045B3B71F9DC6B80D63FDD4A8E9ADB1E6962A69526D43161C1A41D570D7938DAD4A40E329CD0E40E65FFFFFFFFFFFFFFFF
g = 2
expmin = 375
groups[0x0103] = DiffieHellmanParameters(p, g, expmin)

# ffdhe8192
p = 0xFFFFFFFFFFFFFFFFADF85458A2BB4A9AAFDC5620273D3CF1D8B9C583CE2D3695A9E13641146433FBCC939DCE249B3EF97D2FE363630C75D8F681B202AEC4617AD3DF1ED5D5FD65612433F51F5F066ED0856365553DED1AF3B557135E7F57C935984F0C70E0E68B77E2A689DAF3EFE8721DF158A136ADE73530ACCA4F483A797ABC0AB182B324FB61D108A94BB2C8E3FBB96ADAB760D7F4681D4F42A3DE394DF4AE56EDE76372BB190B07A7C8EE0A6D709E02FCE1CDF7E2ECC03404CD28342F619172FE9CE98583FF8E4F1232EEF28183C3FE3B1B4C6FAD733BB5FCBC2EC22005C58EF1837D1683B2C6F34A26C1B2EFFA886B4238611FCFDCDE355B3B6519035BBC34F4DEF99C023861B46FC9D6E6C9077AD91D2691F7F7EE598CB0FAC186D91CAEFE130985139270B4130C93BC437944F4FD4452E2D74DD364F2E21E71F54BFF5CAE82AB9C9DF69EE86D2BC522363A0DABC521979B0DEADA1DBF9A42D5C4484E0ABCD06BFA53DDEF3C1B20EE3FD59D7C25E41D2B669E1EF16E6F52C3164DF4FB7930E9E4E58857B6AC7D5F42D69F6D187763CF1D5503400487F55BA57E31CC7A7135C886EFB4318AED6A1E012D9E6832A907600A918130C46DC778F971AD0038092999A333CB8B7A1A1DB93D7140003C2A4ECEA9F98D0ACC0A8291CDCEC97DCF8EC9B55A7F88A46B4DB5A851F44182E1C68A007E5E0DD9020BFD64B645036C7A4E677D2C38532A3A23BA4442CAF53EA63BB454329B7624C8917BDD64B1C0FD4CB38E8C334C701C3ACDAD0657FCCFEC719B1F5C3E4E46041F388147FB4CFDB477A52471F7A9A96910B855322EDB6340D8A00EF092350511E30ABEC1FFF9E3A26E7FB29F8C183023C3587E38DA0077D9B4763E4E4B94B2BBC194C6651E77CAF992EEAAC0232A281BF6B3A739C1226116820AE8DB5847A67CBEF9C9091B462D538CD72B03746AE77F5E62292C311562A846505DC82DB854338AE49F5235C95B91178CCF2DD5CACEF403EC9D1810C6272B045B3B71F9DC6B80D63FDD4A8E9ADB1E6962A69526D43161C1A41D570D7938DAD4A40E329CCFF46AAA36AD004CF600C8381E425A31D951AE64FDB23FCEC9509D43687FEB69EDD1CC5E0B8CC3BDF64B10EF86B63142A3AB8829555B2F747C932665CB2C0F1CC01BD70229388839D2AF05E454504AC78B7582822846C0BA35C35F5C59160CC046FD8251541FC68C9C86B022BB7099876A460E7451A8A93109703FEE1C217E6C3826E52C51AA691E0E423CFC99E9E31650C1217B624816CDAD9A95F9D5B8019488D9C0A0A1FE3075A577E23183F81D4A3F2FA4571EFC8CE0BA8A4FE8B6855DFE72B0A66EDED2FBABFBE58A30FAFABE1C5D71A87E2F741EF8C1FE86FEA6BBFDE530677F0D97D11D49F7A8443D0822E506A9F4614E011E2A94838FF88CD68C8BB7C5C6424CFFFFFFFFFFFFFFFF
g = 2
expmin = 400
groups[0x0104] = DiffieHellmanParameters(p, g, expmin)



params = groups[0x0101]

r=Random.new()
sa = r.read((params.expmin+7)/8)
sb = r.read((params.expmin+7)/8)
a = bytesToLong(sa)
b = bytesToLong(sb)
a |= (1<<((params.expmin+7)/8*8))
b |= (1<<((params.expmin+7)/8*8))

t1 = time.time()
A = params.send(a)
B = params.send(b)
shared1 = B.recv(a)
shared2 = A.recv(b)
assert shared1 == shared2
t2 = time.time()
print (t2 - t1)*1e6, "us"

print len(params.sendPad(a))
print len(params.sendPad(b))

A = IntermediateDiffieHellman(params, params.sendPad(a))
B = IntermediateDiffieHellman(params, params.sendPad(b))
shared1 = B.recv(a)
shared2 = A.recv(b)
assert shared1 == shared2

with open("../http2/key.pem") as f:
  myPriv = myImportKey(f.read())
with open("../http2/cert.pem") as f:
  myPub = myImportCert(f.read())

sm = r.read(1000/8)
m = long(binascii.hexlify(sm), 16)
c = myPub.verifyEncrypt(m)
t1 = time.time()
m2 = myPriv.signDecrypt(c)
t2 = time.time()
print (t2 - t1)*1e6, "us"
assert m == m2

def pkcs1pad(key, msg, hashfn=SHA256):
  Ts = {SHA256: longToBytes(0x3031300d060960864801650304020105000420)}
  T = Ts[hashfn]
  hasher = hashfn.new()
  hasher.update(msg)
  hashbytes = hasher.digest()
  prefix = "\x00\x01"
  suffix = "\x00" + T + hashbytes
  bitlen = long(key.n).bit_length()
  padcnt = bitlen/8 - len(prefix) - len(suffix)
  bitinteger = prefix + padcnt*"\xFF"+suffix
  return bitinteger

def pkcs1sign(key, msg, hashfn=SHA256):
  return longToBytes(key.signDecrypt(bytesToLong(pkcs1pad(key, msg, hashfn))))

def pkcs1verify(pub, signature, msg, hashfn=SHA256):
  bs = longToBytes(pub.verifyEncrypt(bytesToLong(signature)))
  integer = pub.verifyEncrypt(bytesToLong(signature))
  assert integer == bytesToLong(pkcs1pad(pub, msg, hashfn))

msg = "foo bar baz"
assert pkcs1pad(myPub, msg) == pkcs1pad(myPriv, msg)

signature = pkcs1sign(myPriv, msg)
pkcs1verify(myPub, signature, msg)
